{"dependencies":[{"name":"/Users/cody/Dev/github/atom-next/tsconfig.json","includedInParent":true,"mtime":1518109073000}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AtomState;\n(function (AtomState) {\n    AtomState[\"ACTUAL\"] = \"ACTUAL\";\n    AtomState[\"MAYBE_DIRTY\"] = \"MAYBE_DIRTY\";\n})(AtomState = exports.AtomState || (exports.AtomState = {}));\nlet activeChildAtom;\nclass Transaction {\n    constructor(transactionId, atom) {\n        this.transactionId = transactionId;\n        this.atom = atom;\n        this.changes = [];\n        this.changesLength = 0;\n    }\n}\nclass TransactionManager {\n    constructor() {\n        this.transactionIdIdx = 0;\n        this.current = new Transaction(this.transactionIdIdx++, undefined);\n        this.stack = [this.current];\n        this.pos = 0;\n    }\n    start(atom) {\n        if (this.pos === this.stack.length - 1) {\n            this.stack.push(new Transaction(this.transactionIdIdx++, atom));\n        }\n        this.possibleToUseAtomAsSlave(atom);\n        this.current = this.stack[++this.pos];\n        this.current.changesLength = atom.masters.length;\n        this.current.atom = atom;\n        if (this.current.changesLength > this.current.changes.length) {\n            this.current.changes[this.current.changesLength - 1] = -1;\n        }\n    }\n    end() {\n        this.current.atom = void 0;\n        this.current = this.stack[--this.pos];\n    }\n    possibleToUseAtomAsSlave(atom) {\n        for (let i = 1; i <= this.pos; i++) {\n            const transaction = this.stack[i];\n            if (transaction.atom === atom) {\n                const path = [];\n                for (let j = i; j <= this.pos; j++) {\n                    path.push(this.stack[j].atom.name);\n                }\n                throw new Error(`Cyclic dependency detected: ${path.join('->')}`);\n            }\n            if (transaction.transactionId === atom.createdInTransaction) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nconst trxManager = new TransactionManager();\nconst updateList = { list: [], pos: 0 };\nfunction run() {\n    for (let i = 0; i < updateList.pos; i++) {\n        const atom = updateList.list[i];\n        atom.actualize();\n        updateList.list[i] = undefined;\n    }\n    updateList.pos = 0;\n}\nexports.run = run;\nclass Atom {\n    constructor() {\n        this.slaves = void 0;\n        this.masters = undefined;\n        this.calcFun = void 0;\n        this.value = undefined;\n        this.state = AtomState.ACTUAL;\n        this.createdInTransaction = trxManager.current.transactionId;\n    }\n    static value(value, name) {\n        const atom = new Atom();\n        atom.value = value;\n        atom.name = name;\n        return atom;\n    }\n    static calc(fn, name) {\n        const atom = new Atom();\n        atom.name = name;\n        atom.calcFun = fn;\n        atom.state = AtomState.MAYBE_DIRTY;\n        return atom;\n    }\n    static autorun(fn, name) {\n        const atom = Atom.calc(fn, name);\n        atom.get();\n        return atom;\n    }\n    detach() {\n        for (let i = 0; i < this.masters.length; i += 2) {\n            const parent = this.masters[i];\n            for (let j = 0; j < parent.slaves.length; j++) {\n                if (this === parent.slaves[j]) {\n                    parent.slaves.splice(j, 2);\n                    break;\n                }\n            }\n        }\n        while (this.masters.length > 0)\n            this.masters.pop();\n    }\n    set(value) {\n        // console.log('set', value, this);\n        this.value = value;\n        updateList.list[updateList.pos++] = this;\n        this.setChildrenMaybeState();\n    }\n    actualize() {\n        console.log('actualize', this.name, this.state, this.value);\n        if (this.state === AtomState.MAYBE_DIRTY) {\n            this.calc(false);\n        }\n        if (this.slaves !== void 0) {\n            loop: for (let i = 0; i < this.slaves.length; i++) {\n                const child = this.slaves[i];\n                for (let i = 0; i < child.masters.length; i += 2) {\n                    const master = child.masters[i];\n                    // console.log('master', master);\n                    if (master === child)\n                        continue;\n                    if (master.state === AtomState.MAYBE_DIRTY) {\n                        continue loop;\n                    }\n                }\n                if (child.state !== AtomState.ACTUAL) {\n                    child.actualize();\n                }\n            }\n        }\n    }\n    setChildrenMaybeState() {\n        if (this.slaves !== void 0) {\n            for (let i = 0; i < this.slaves.length; i++) {\n                const child = this.slaves[i];\n                if (child.state === AtomState.ACTUAL) {\n                    child.state = AtomState.MAYBE_DIRTY;\n                    child.setChildrenMaybeState();\n                }\n            }\n        }\n    }\n    removeChild(child) {\n        for (let i = 0; i < this.slaves.length; i++) {\n            if (child === this.slaves[i]) {\n                this.slaves.splice(i, 1);\n                return;\n            }\n        }\n    }\n    processTransaction() {\n        let shift = 0;\n        for (let i = 0; i < trxManager.current.changesLength; i += 2) {\n            if (trxManager.current.changes[i] !== trxManager.current.transactionId) {\n                const parent = this.masters[i - shift];\n                parent.removeChild(this);\n                this.masters.splice(i - shift, 2);\n                shift += 2;\n            }\n        }\n    }\n    calc(setChildrenMaybeState) {\n        trxManager.start(this);\n        console.log('precalc', this.name, this.value);\n        try {\n            const newValue = this.calcFun();\n            const hasChanged = newValue !== this.value;\n            if (hasChanged && setChildrenMaybeState) {\n                this.setChildrenMaybeState();\n            }\n            this.processTransaction();\n            this.state = AtomState.ACTUAL;\n            this.value = newValue;\n            return hasChanged;\n        }\n        finally {\n            trxManager.end();\n            console.log('postcalc', this.name, this.value);\n        }\n    }\n    calcIfNeeded() {\n        console.log('calcIfNeeded', this.name, this.state, this.value);\n        if (this.state === AtomState.MAYBE_DIRTY) {\n            if (this.masters === void 0) {\n                this.masters = [];\n                return this.calc(true);\n            }\n            for (let i = 0; i < this.masters.length; i += 2) {\n                const parent = this.masters[i];\n                const value = this.masters[i + 1];\n                if (parent.value !== value || parent.calcIfNeeded()) {\n                    if (this.calc(true)) {\n                        return true;\n                    }\n                }\n            }\n            this.state = AtomState.ACTUAL;\n        }\n        return false;\n    }\n    addChild(atom) {\n        if (this.slaves === void 0) {\n            this.slaves = [];\n        }\n        for (let i = 0; i < this.slaves.length; i++) {\n            const child = this.slaves[i];\n            if (atom === child) {\n                return i;\n            }\n        }\n        this.slaves.push(atom);\n        return -1;\n    }\n    addParent(atom) {\n        for (let i = 0; i < this.masters.length; i += 2) {\n            const parent = this.masters[i];\n            if (parent === atom) {\n                return i;\n            }\n        }\n        this.masters.push(atom, atom.value);\n        return -1;\n    }\n    processMaster() {\n        const { current } = trxManager;\n        if (current.atom !== void 0) {\n            // if (!trxManager.possibleToUseAtomAsSlave(this)) {\n            //     return;\n            // }\n            const foundPos = current.atom.addParent(this);\n            if (foundPos === -1) {\n                this.addChild(current.atom);\n            }\n            else {\n                current.changes[foundPos] = current.transactionId;\n            }\n        }\n    }\n    get() {\n        this.calcIfNeeded();\n        this.processMaster();\n        return this.value;\n    }\n}\nexports.Atom = Atom;\n","map":{"version":3,"file":"atom.js","sourceRoot":"","sources":["atom.ts"],"names":[],"mappings":"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","sourcesContent":["export const enum AtomState {\n    ACTUAL = 'ACTUAL',\n    MAYBE_DIRTY = 'MAYBE_DIRTY',\n}\n\nlet activeChildAtom: Atom;\n\nclass Transaction {\n    changes: number[] = [];\n    changesLength = 0;\n    constructor(public transactionId: number, public atom?: Atom) {}\n}\n\nclass TransactionManager {\n    private transactionIdIdx = 0;\n    current = new Transaction(this.transactionIdIdx++, undefined);\n    private stack: Transaction[] = [this.current];\n    private pos = 0;\n    start(atom: Atom) {\n        if (this.pos === this.stack.length - 1) {\n            this.stack.push(new Transaction(this.transactionIdIdx++, atom));\n        }\n        this.possibleToUseAtomAsSlave(atom);\n        this.current = this.stack[++this.pos];\n        this.current.changesLength = atom.masters.length;\n        this.current.atom = atom;\n        if (this.current.changesLength > this.current.changes.length) {\n            this.current.changes[this.current.changesLength - 1] = -1;\n        }\n    }\n\n    end() {\n        this.current.atom = void 0;\n        this.current = this.stack[--this.pos];\n    }\n\n    possibleToUseAtomAsSlave(atom: Atom) {\n        for (let i = 1; i <= this.pos; i++) {\n            const transaction = this.stack[i];\n            if (transaction.atom === atom) {\n                const path = [];\n                for (let j = i; j <= this.pos; j++) {\n                    path.push(this.stack[j].atom!.name);\n                }\n                throw new Error(`Cyclic dependency detected: ${path.join('->')}`);\n            }\n            if (transaction.transactionId === atom.createdInTransaction) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nconst trxManager = new TransactionManager();\n\nconst updateList = { list: [] as Atom[], pos: 0 };\n\nexport function run() {\n    for (let i = 0; i < updateList.pos; i++) {\n        const atom = updateList.list[i];\n        atom.actualize();\n        updateList.list[i] = undefined!;\n    }\n    updateList.pos = 0;\n}\n\nexport class Atom<T = {}> {\n    slaves?: Atom[] = void 0;\n    masters: (Atom | {})[] = undefined!;\n    calcFun?: () => T = void 0;\n    value: T = undefined!;\n    state: AtomState = AtomState.ACTUAL;\n    name?: string;\n    createdInTransaction = trxManager.current.transactionId;\n\n    constructor() {}\n\n    static value<T>(value: T, name?: string) {\n        const atom = new Atom<T>();\n        atom.value = value;\n        atom.name = name;\n        return atom;\n    }\n\n    static calc<T>(fn: () => T, name?: string) {\n        const atom = new Atom<T>();\n        atom.name = name;\n        atom.calcFun = fn;\n        atom.state = AtomState.MAYBE_DIRTY;\n        return atom;\n    }\n\n    static autorun(fn: () => void, name?: string) {\n        const atom = Atom.calc(fn, name);\n        atom.get();\n        return atom;\n    }\n\n    detach() {\n        for (let i = 0; i < this.masters.length; i += 2) {\n            const parent = this.masters[i] as Atom;\n            for (let j = 0; j < parent.slaves!.length; j++) {\n                if (this === parent.slaves![j]) {\n                    parent.slaves!.splice(j, 2);\n                    break;\n                }\n            }\n        }\n        while (this.masters.length > 0) this.masters.pop();\n    }\n\n    set(value: T) {\n        // console.log('set', value, this);\n        this.value = value;\n        updateList.list[updateList.pos++] = this;\n        this.setChildrenMaybeState();\n    }\n\n    actualize() {\n        console.log('actualize', this.name, this.state, this.value);\n        if (this.state === AtomState.MAYBE_DIRTY) {\n            this.calc(false);\n        }\n        if (this.slaves !== void 0) {\n            loop: for (let i = 0; i < this.slaves.length; i++) {\n                const child = this.slaves[i];\n                for (let i = 0; i < child.masters.length; i += 2) {\n                    const master = child.masters[i] as Atom;\n                    // console.log('master', master);\n                    if (master === child) continue;\n                    if (master.state === AtomState.MAYBE_DIRTY) {\n                        continue loop;\n                    }\n                }\n                if (child.state !== AtomState.ACTUAL) {\n                    child.actualize();\n                }\n            }\n        }\n    }\n\n    setChildrenMaybeState() {\n        if (this.slaves !== void 0) {\n            for (let i = 0; i < this.slaves.length; i++) {\n                const child = this.slaves[i];\n                if (child.state === AtomState.ACTUAL) {\n                    child.state = AtomState.MAYBE_DIRTY;\n                    child.setChildrenMaybeState();\n                }\n            }\n        }\n    }\n\n    removeChild(child: Atom) {\n        for (let i = 0; i < this.slaves!.length; i++) {\n            if (child === this.slaves![i]) {\n                this.slaves!.splice(i, 1);\n                return;\n            }\n        }\n    }\n\n    processTransaction() {\n        let shift = 0;\n        for (let i = 0; i < trxManager.current.changesLength; i += 2) {\n            if (trxManager.current.changes[i] !== trxManager.current.transactionId) {\n                const parent = this.masters[i - shift] as Atom;\n                parent.removeChild(this);\n                this.masters.splice(i - shift, 2);\n                shift += 2;\n            }\n        }\n    }\n\n    calc(setChildrenMaybeState: boolean) {\n        trxManager.start(this);\n        console.log('precalc', this.name, this.value);\n        try {\n            const newValue = this.calcFun!();\n            const hasChanged = newValue !== this.value;\n            if (hasChanged && setChildrenMaybeState) {\n                this.setChildrenMaybeState();\n            }\n            this.processTransaction();\n            this.state = AtomState.ACTUAL;\n            this.value = newValue;\n            return hasChanged;\n        } finally {\n            trxManager.end();\n            console.log('postcalc', this.name, this.value);\n        }\n    }\n\n    calcIfNeeded() {\n        console.log('calcIfNeeded', this.name, this.state, this.value);\n        if (this.state === AtomState.MAYBE_DIRTY) {\n            if (this.masters === void 0) {\n                this.masters = [];\n                return this.calc(true);\n            }\n            for (let i = 0; i < this.masters.length; i += 2) {\n                const parent = this.masters[i] as Atom;\n                const value = this.masters[i + 1];\n                if (parent.value !== value || parent.calcIfNeeded()) {\n                    if (this.calc(true)) {\n                        return true;\n                    }\n                }\n            }\n            this.state = AtomState.ACTUAL;\n        }\n        return false;\n    }\n\n    addChild(atom: Atom) {\n        if (this.slaves === void 0) {\n            this.slaves = [];\n        }\n        for (let i = 0; i < this.slaves.length; i++) {\n            const child = this.slaves[i];\n            if (atom === child) {\n                return i;\n            }\n        }\n        this.slaves.push(atom);\n        return -1;\n    }\n\n    addParent(atom: Atom) {\n        for (let i = 0; i < this.masters.length; i += 2) {\n            const parent = this.masters[i];\n            if (parent === atom) {\n                return i;\n            }\n        }\n        this.masters.push(atom, atom.value);\n        return -1;\n    }\n\n    processMaster() {\n        const { current } = trxManager;\n        if (current.atom !== void 0) {\n            // if (!trxManager.possibleToUseAtomAsSlave(this)) {\n            //     return;\n            // }\n            const foundPos = current.atom.addParent(this);\n            if (foundPos === -1) {\n                this.addChild(current.atom);\n            } else {\n                current.changes[foundPos] = current.transactionId;\n            }\n        }\n    }\n\n    get() {\n        this.calcIfNeeded();\n        this.processMaster();\n        return this.value;\n    }\n}\n"]}},"hash":"dd3c977883130071e359fbb21b070670","cacheData":{"env":{}}}