{"dependencies":[{"name":"/Users/cody/Dev/github/atom-next/tsconfig.json","includedInParent":true,"mtime":1518197409000}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AtomState;\n(function (AtomState) {\n    AtomState[\"ACTUAL\"] = \"ACTUAL\";\n    AtomState[\"MAYBE_DIRTY\"] = \"MAYBE_DIRTY\";\n})(AtomState = exports.AtomState || (exports.AtomState = {}));\nclass Transaction {\n    constructor(transactionId, atom) {\n        this.transactionId = transactionId;\n        this.atom = atom;\n        this.changes = [];\n        this.changesLength = 0;\n    }\n}\nclass TransactionManager {\n    constructor() {\n        this.transactionIdIdx = 0;\n        this.current = new Transaction(this.transactionIdIdx++, undefined);\n        this.stack = [this.current];\n        this.pos = 0;\n    }\n    start(atom) {\n        if (this.pos === this.stack.length - 1) {\n            this.stack.push(new Transaction(this.transactionIdIdx++, atom));\n        }\n        this.possibleToUseAtomAsSlave(atom);\n        this.current = this.stack[++this.pos];\n        this.current.changesLength = atom.masters.length;\n        this.current.atom = atom;\n        if (this.current.changesLength > this.current.changes.length) {\n            this.current.changes[this.current.changesLength - 1] = -1;\n        }\n    }\n    end() {\n        this.current.atom = void 0;\n        this.current = this.stack[--this.pos];\n    }\n    possibleToUseAtomAsSlave(atom) {\n        for (let i = 1; i <= this.pos; i++) {\n            const transaction = this.stack[i];\n            if (transaction.atom === atom) {\n                const path = [];\n                for (let j = i; j <= this.pos; j++) {\n                    path.push(this.stack[j].atom.name);\n                }\n                throw new Error(`Cyclic dependency detected: ${path.join('->')}`);\n            }\n            // if (transaction.transactionId === atom.createdInTransaction) {\n            // return false;\n            // }\n        }\n        return true;\n    }\n}\nconst trxManager = new TransactionManager();\nconst updateList = { list: [], pos: 0 };\nfunction run() {\n    for (let i = 0; i < updateList.pos; i++) {\n        const atom = updateList.list[i];\n        actualize(atom);\n        updateList.list[i] = undefined;\n    }\n    updateList.pos = 0;\n}\nexports.run = run;\n/*\nexport class Atom<T = {}> {\n    slaves?: Atom[] = void 0;\n    masters: (Atom | {})[] = undefined!;\n    calcFun?: () => T = void 0;\n    value: T = undefined!;\n    state: AtomState = AtomState.ACTUAL;\n    name?: string;\n    createdInTransaction = trxManager.current.transactionId;\n\n    constructor() {}\n\n    static value<T>(value: T, name?: string) {\n        const atom = new Atom<T>();\n        atom.value = value;\n        atom.name = name;\n        return atom;\n    }\n\n    static calc<T>(fn: () => T, name?: string) {\n        const atom = new Atom<T>();\n        atom.name = name;\n        atom.calcFun = fn;\n        atom.state = AtomState.MAYBE_DIRTY;\n        return atom;\n    }\n\n    static autorun(fn: () => void, name?: string) {\n        const atom = Atom.calc(fn, name);\n        atom.get();\n        return atom;\n    }\n\n    detach() {\n        for (let i = 0; i < this.masters.length; i += 2) {\n            const parent = this.masters[i] as Atom;\n            for (let j = 0; j < parent.slaves!.length; j++) {\n                if (this === parent.slaves![j]) {\n                    parent.slaves!.splice(j, 2);\n                    break;\n                }\n            }\n        }\n        while (this.masters.length > 0) this.masters.pop();\n    }\n\n    set(value: T) {\n        // console.log('set', value, this);\n        this.value = value;\n        updateList.list[updateList.pos++] = this;\n        this.setChildrenMaybeState();\n    }\n\n    actualize() {\n        console.log('actualize', this.name, this.state, this.value);\n        if (this.state === AtomState.MAYBE_DIRTY) {\n            this.calc(false);\n        }\n        if (this.slaves !== void 0) {\n            loop: for (let i = 0; i < this.slaves.length; i++) {\n                const child = this.slaves[i];\n                for (let i = 0; i < child.masters.length; i += 2) {\n                    const master = child.masters[i] as Atom;\n                    // console.log('master', master);\n                    if (master === child) continue;\n                    if (master.state === AtomState.MAYBE_DIRTY) {\n                        continue loop;\n                    }\n                }\n                if (child.state !== AtomState.ACTUAL) {\n                    child.actualize();\n                }\n            }\n        }\n    }\n\n    setChildrenMaybeState() {\n        if (this.slaves !== void 0) {\n            for (let i = 0; i < this.slaves.length; i++) {\n                const child = this.slaves[i];\n                if (child.state === AtomState.ACTUAL) {\n                    child.state = AtomState.MAYBE_DIRTY;\n                    child.setChildrenMaybeState();\n                }\n            }\n        }\n    }\n\n    removeChild(child: Atom) {\n        for (let i = 0; i < this.slaves!.length; i++) {\n            if (child === this.slaves![i]) {\n                this.slaves!.splice(i, 1);\n                return;\n            }\n        }\n    }\n\n    processTransaction() {\n        let shift = 0;\n        for (let i = 0; i < trxManager.current.changesLength; i += 2) {\n            if (trxManager.current.changes[i] !== trxManager.current.transactionId) {\n                const parent = this.masters[i - shift] as Atom;\n                parent.removeChild(this);\n                this.masters.splice(i - shift, 2);\n                shift += 2;\n            }\n        }\n    }\n\n    calc(setChildrenMaybeState: boolean) {\n        trxManager.start(this);\n        console.log('precalc', this.name, this.value);\n        try {\n            const newValue = this.calcFun!();\n            const hasChanged = newValue !== this.value;\n            if (hasChanged && setChildrenMaybeState) {\n                this.setChildrenMaybeState();\n            }\n            this.processTransaction();\n            this.state = AtomState.ACTUAL;\n            this.value = newValue;\n            return hasChanged;\n        } finally {\n            trxManager.end();\n            console.log('postcalc', this.name, this.value);\n        }\n    }\n\n    calcIfNeeded() {\n        console.log('calcIfNeeded', this.name, this.state, this.value);\n        if (this.state === AtomState.MAYBE_DIRTY) {\n            if (this.masters === void 0) {\n                this.masters = [];\n                return this.calc(true);\n            }\n            for (let i = 0; i < this.masters.length; i += 2) {\n                const parent = this.masters[i] as Atom;\n                const value = this.masters[i + 1];\n                if (parent.value !== value || parent.calcIfNeeded()) {\n                    if (this.calc(true)) {\n                        return true;\n                    }\n                }\n            }\n            this.state = AtomState.ACTUAL;\n        }\n        return false;\n    }\n\n    addChild(atom: Atom) {\n        if (this.slaves === void 0) {\n            this.slaves = [];\n        }\n        for (let i = 0; i < this.slaves.length; i++) {\n            const child = this.slaves[i];\n            if (atom === child) {\n                return i;\n            }\n        }\n        this.slaves.push(atom);\n        return -1;\n    }\n\n    addParent(atom: Atom) {\n        for (let i = 0; i < this.masters.length; i += 2) {\n            const parent = this.masters[i];\n            if (parent === atom) {\n                return i;\n            }\n        }\n        this.masters.push(atom, atom.value);\n        return -1;\n    }\n\n    processMaster() {\n        const { current } = trxManager;\n        if (current.atom !== void 0) {\n            // if (!trxManager.possibleToUseAtomAsSlave(this)) {\n            //     return;\n            // }\n            const foundPos = current.atom.addParent(this);\n            if (foundPos === -1) {\n                this.addChild(current.atom);\n            } else {\n                current.changes[foundPos] = current.transactionId;\n            }\n        }\n    }\n\n    get() {\n        this.calcIfNeeded();\n        this.processMaster();\n        return this.value;\n    }\n}\n*/\nfunction actualize(atom) {\n    console.log('actualize', atom.name, atom.value);\n    if (atom.slaves !== void 0) {\n        loop: for (let i = 0; i < atom.slaves.length; i++) {\n            const child = atom.slaves[i];\n            for (let i = 0; i < child.masters.length; i += 2) {\n                const master = child.masters[i];\n                // console.log('master', master);\n                if (master === child)\n                    continue;\n                if (master.state === AtomState.MAYBE_DIRTY) {\n                    continue loop;\n                }\n            }\n            if (child.state === AtomState.MAYBE_DIRTY) {\n                calc(child, false);\n                actualize(child);\n            }\n        }\n    }\n}\nfunction setChildrenMaybeState(atom) {\n    if (atom.slaves !== void 0) {\n        for (let i = 0; i < atom.slaves.length; i++) {\n            const child = atom.slaves[i];\n            if (child.state === AtomState.ACTUAL) {\n                child.state = AtomState.MAYBE_DIRTY;\n                setChildrenMaybeState(child);\n            }\n        }\n    }\n}\nfunction removeChild(atom, child) {\n    if (atom.slaves !== void 0) {\n        for (let i = 0; i < atom.slaves.length; i++) {\n            if (child === atom.slaves[i]) {\n                atom.slaves.splice(i, 1);\n                return;\n            }\n        }\n    }\n}\nfunction addChild(atom, atomChild) {\n    if (atom.slaves === void 0) {\n        atom.slaves = [];\n    }\n    for (let i = 0; i < atom.slaves.length; i++) {\n        const child = atom.slaves[i];\n        if (atomChild === child) {\n            return i;\n        }\n    }\n    atom.slaves.push(atomChild);\n    return -1;\n}\nfunction addParent(atom, atomParent) {\n    for (let i = 0; i < atom.masters.length; i += 2) {\n        const parent = atom.masters[i];\n        if (parent === atomParent) {\n            return i;\n        }\n    }\n    atom.masters.push(atomParent, atomParent.value);\n    return -1;\n}\nfunction processMaster(atom) {\n    const { current } = trxManager;\n    if (current.atom !== void 0) {\n        // if (!trxManager.possibleToUseAtomAsSlave(this)) {\n        //     return;\n        // }\n        const foundPos = addParent(current.atom, atom);\n        if (foundPos === -1) {\n            addChild(atom, current.atom);\n        }\n        else {\n            current.changes[foundPos] = current.transactionId;\n        }\n    }\n}\nfunction calc(atom, setChildrenMaybeState1) {\n    trxManager.start(atom);\n    console.log('precalc', atom.name, atom.value);\n    try {\n        const newValue = atom.calcFun();\n        const hasChanged = newValue !== atom.value;\n        if (hasChanged && setChildrenMaybeState1) {\n            setChildrenMaybeState(atom);\n        }\n        processTransaction(atom);\n        atom.state = AtomState.ACTUAL;\n        atom.value = newValue;\n        return hasChanged;\n    }\n    finally {\n        trxManager.end();\n        console.log('postcalc', atom.name, atom.value);\n    }\n}\nfunction calcIfNeeded(atom) {\n    console.log('calcIfNeeded', atom.name, atom.state, atom.value);\n    if (atom.masters === void 0) {\n        atom.masters = [];\n        return calc(atom, true);\n    }\n    for (let i = 0; i < atom.masters.length; i += 2) {\n        const parent = atom.masters[i];\n        const value = atom.masters[i + 1];\n        if (parent.value !== value || (parent.state === AtomState.MAYBE_DIRTY && calcIfNeeded(parent))) {\n            if (calc(atom, true)) {\n                return true;\n            }\n        }\n    }\n    atom.state = AtomState.ACTUAL;\n    return false;\n}\nfunction processTransaction(atom) {\n    let shift = 0;\n    for (let i = 0; i < trxManager.current.changesLength; i += 2) {\n        if (trxManager.current.changes[i] !== trxManager.current.transactionId) {\n            const parent = atom.masters[i - shift];\n            removeChild(parent, atom);\n            atom.masters.splice(i - shift, 2);\n            shift += 2;\n        }\n    }\n}\nclass AtomCalc {\n    constructor(calcFun, name) {\n        this.name = name;\n        this.slaves = void 0;\n        this.masters = undefined;\n        this.value = undefined;\n        this.state = AtomState.MAYBE_DIRTY;\n        this.calcFun = calcFun;\n    }\n    static autorun(calcFun, name) {\n        const atom = new AtomCalc(calcFun, name);\n        atom.get();\n        return atom;\n    }\n    detach() {\n        for (let i = 0; i < this.masters.length; i += 2) {\n            const parent = this.masters[i];\n            if (parent.slaves !== void 0) {\n                for (let j = 0; j < parent.slaves.length; j++) {\n                    if (this === parent.slaves[j]) {\n                        parent.slaves.splice(j, 2);\n                        break;\n                    }\n                }\n            }\n        }\n        while (this.masters.length > 0)\n            this.masters.pop();\n    }\n    get() {\n        if (this.state === AtomState.MAYBE_DIRTY) {\n            calcIfNeeded(this);\n        }\n        processMaster(this);\n        return this.value;\n    }\n}\nexports.AtomCalc = AtomCalc;\nclass AtomValue {\n    constructor(value, name) {\n        this.name = name;\n        this.slaves = void 0;\n        this.value = value;\n    }\n    set(value) {\n        this.value = value;\n        updateList.list[updateList.pos++] = this;\n        setChildrenMaybeState(this);\n    }\n    get() {\n        processMaster(this);\n        return this.value;\n    }\n}\nexports.AtomValue = AtomValue;\nAtomValue.prototype.state = AtomState.ACTUAL;\n","map":{"version":3,"file":"atom.js","sourceRoot":"","sources":["atom.ts"],"names":[],"mappings":";;AAAA,IAAkB,SAGjB;AAHD,WAAkB,SAAS;IACvB,8BAAiB,CAAA;IACjB,wCAA2B,CAAA;AAC/B,CAAC,EAHiB,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAG1B;AAED;IAGI,YAAmB,aAAqB,EAAS,IAAe;QAA7C,kBAAa,GAAb,aAAa,CAAQ;QAAS,SAAI,GAAJ,IAAI,CAAW;QAFhE,YAAO,GAAa,EAAE,CAAC;QACvB,kBAAa,GAAG,CAAC,CAAC;IACiD,CAAC;CACvE;AAED;IAAA;QACY,qBAAgB,GAAG,CAAC,CAAC;QAC7B,YAAO,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,gBAAgB,EAAE,EAAE,SAAS,CAAC,CAAC;QACtD,UAAK,GAAkB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACtC,QAAG,GAAG,CAAC,CAAC;IAmCpB,CAAC;IAlCG,KAAK,CAAC,IAAc;QAChB,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACrC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,IAAI,CAAC,gBAAgB,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC;QACpE,CAAC;QACD,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;QACpC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;QACtC,IAAI,CAAC,OAAO,CAAC,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;QACjD,IAAI,CAAC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC;QACzB,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;YAC3D,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAC9D,CAAC;IACL,CAAC;IAED,GAAG;QACC,IAAI,CAAC,OAAO,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC;QAC3B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;IAC1C,CAAC;IAED,wBAAwB,CAAC,IAAU;QAC/B,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;YACjC,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAClC,EAAE,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC;gBAC5B,MAAM,IAAI,GAAG,EAAE,CAAC;gBAChB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;oBACjC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAK,CAAC,IAAI,CAAC,CAAC;gBACxC,CAAC;gBACD,MAAM,IAAI,KAAK,CAAC,+BAA+B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YACtE,CAAC;YACD,iEAAiE;YACjE,gBAAgB;YAChB,IAAI;QACR,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;CACJ;AAED,MAAM,UAAU,GAAG,IAAI,kBAAkB,EAAE,CAAC;AAE5C,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE,EAAiB,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC;AAEvD;IACI,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;QACtC,MAAM,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAChC,SAAS,CAAC,IAAI,CAAC,CAAC;QAChB,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,SAAU,CAAC;IACpC,CAAC;IACD,UAAU,CAAC,GAAG,GAAG,CAAC,CAAC;AACvB,CAAC;AAPD,kBAOC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAmME;AAEF,mBAAmB,IAAU;IACzB,OAAO,CAAC,GAAG,CAAC,WAAW,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;IAChD,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;QACzB,IAAI,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAChD,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAC7B,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;gBAC/C,MAAM,MAAM,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAS,CAAC;gBACxC,iCAAiC;gBACjC,EAAE,CAAC,CAAC,MAAM,KAAK,KAAK,CAAC;oBAAC,QAAQ,CAAC;gBAC/B,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,KAAK,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC;oBACzC,QAAQ,CAAC,IAAI,CAAC;gBAClB,CAAC;YACL,CAAC;YACD,EAAE,CAAC,CAAC,KAAK,CAAC,KAAK,KAAK,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC;gBACxC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;gBACnB,SAAS,CAAC,KAAK,CAAC,CAAC;YACrB,CAAC;QACL,CAAC;IACL,CAAC;AACL,CAAC;AAED,+BAA+B,IAAU;IACrC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;QACzB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC1C,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAC7B,EAAE,CAAC,CAAC,KAAK,CAAC,KAAK,KAAK,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;gBACnC,KAAK,CAAC,KAAK,GAAG,SAAS,CAAC,WAAW,CAAC;gBACpC,qBAAqB,CAAC,KAAK,CAAC,CAAC;YACjC,CAAC;QACL,CAAC;IACL,CAAC;AACL,CAAC;AAED,qBAAqB,IAAU,EAAE,KAAW;IACxC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;QACzB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC1C,EAAE,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC3B,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACzB,MAAM,CAAC;YACX,CAAC;QACL,CAAC;IACL,CAAC;AACL,CAAC;AAED,kBAAkB,IAAU,EAAE,SAAmB;IAC7C,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;QACzB,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;IACrB,CAAC;IACD,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QAC1C,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAC7B,EAAE,CAAC,CAAC,SAAS,KAAK,KAAK,CAAC,CAAC,CAAC;YACtB,MAAM,CAAC,CAAC,CAAC;QACb,CAAC;IACL,CAAC;IACD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IAC5B,MAAM,CAAC,CAAC,CAAC,CAAC;AACd,CAAC;AAED,mBAAmB,IAAc,EAAE,UAAgB;IAC/C,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;QAC9C,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAC/B,EAAE,CAAC,CAAC,MAAM,KAAK,UAAU,CAAC,CAAC,CAAC;YACxB,MAAM,CAAC,CAAC,CAAC;QACb,CAAC;IACL,CAAC;IACD,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC;IAChD,MAAM,CAAC,CAAC,CAAC,CAAC;AACd,CAAC;AAED,uBAAuB,IAAU;IAC7B,MAAM,EAAE,OAAO,EAAE,GAAG,UAAU,CAAC;IAC/B,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;QAC1B,oDAAoD;QACpD,cAAc;QACd,IAAI;QACJ,MAAM,QAAQ,GAAG,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAC/C,EAAE,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YAClB,QAAQ,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC;QACjC,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,OAAO,CAAC,aAAa,CAAC;QACtD,CAAC;IACL,CAAC;AACL,CAAC;AAED,cAAc,IAAc,EAAE,sBAA+B;IACzD,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IACvB,OAAO,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;IAC9C,IAAI,CAAC;QACD,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;QAChC,MAAM,UAAU,GAAG,QAAQ,KAAK,IAAI,CAAC,KAAK,CAAC;QAC3C,EAAE,CAAC,CAAC,UAAU,IAAI,sBAAsB,CAAC,CAAC,CAAC;YACvC,qBAAqB,CAAC,IAAI,CAAC,CAAC;QAChC,CAAC;QACD,kBAAkB,CAAC,IAAI,CAAC,CAAC;QACzB,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC;QAC9B,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC;QACtB,MAAM,CAAC,UAAU,CAAC;IACtB,CAAC;YAAS,CAAC;QACP,UAAU,CAAC,GAAG,EAAE,CAAC;QACjB,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;IACnD,CAAC;AACL,CAAC;AAED,sBAAsB,IAAc;IAChC,OAAO,CAAC,GAAG,CAAC,cAAc,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;IAC/D,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;QAC1B,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;QAClB,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IAC5B,CAAC;IACD,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;QAC9C,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAS,CAAC;QACvC,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAClC,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,KAAK,KAAK,IAAI,CAAC,MAAM,CAAC,KAAK,KAAK,SAAS,CAAC,WAAW,IAAI,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YAC7F,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;gBACnB,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;QACL,CAAC;IACL,CAAC;IACD,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC;IAC9B,MAAM,CAAC,KAAK,CAAC;AACjB,CAAC;AAED,4BAA4B,IAAc;IACtC,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,OAAO,CAAC,aAAa,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;QAC3D,EAAE,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,UAAU,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC;YACrE,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,KAAK,CAAS,CAAC;YAC/C,WAAW,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;YAC1B,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,KAAK,EAAE,CAAC,CAAC,CAAC;YAClC,KAAK,IAAI,CAAC,CAAC;QACf,CAAC;IACL,CAAC;AACL,CAAC;AAID;IAOI,YAAY,OAAgB,EAAS,IAAa;QAAb,SAAI,GAAJ,IAAI,CAAS;QANlD,WAAM,GAAgB,KAAK,CAAC,CAAC;QAC7B,YAAO,GAAkB,SAAU,CAAC;QAEpC,UAAK,GAAM,SAAU,CAAC;QACtB,UAAK,GAAG,SAAS,CAAC,WAAW,CAAC;QAG1B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IAC3B,CAAC;IAED,MAAM,CAAC,OAAO,CAAI,OAAgB,EAAE,IAAa;QAC7C,MAAM,IAAI,GAAG,IAAI,QAAQ,CAAI,OAAO,EAAE,IAAI,CAAC,CAAC;QAC5C,IAAI,CAAC,GAAG,EAAE,CAAC;QACX,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAED,MAAM;QACF,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;YAC9C,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAS,CAAC;YACvC,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC3B,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBAC5C,EAAE,CAAC,CAAC,IAAI,KAAK,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBAC5B,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;wBAC3B,KAAK,CAAC;oBACV,CAAC;gBACL,CAAC;YACL,CAAC;QACL,CAAC;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC;YAAE,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;IACvD,CAAC;IAED,GAAG;QACC,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,KAAK,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC;YACvC,YAAY,CAAC,IAAI,CAAC,CAAC;QACvB,CAAC;QACD,aAAa,CAAC,IAAI,CAAC,CAAC;QACpB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;CACJ;AAvCD,4BAuCC;AAED;IAMI,YAAY,KAAQ,EAAS,IAAa;QAAb,SAAI,GAAJ,IAAI,CAAS;QAL1C,WAAM,GAAgB,KAAK,CAAC,CAAC;QAMzB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACvB,CAAC;IAED,GAAG,CAAC,KAAQ;QACR,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC;QACzC,qBAAqB,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC;IAED,GAAG;QACC,aAAa,CAAC,IAAI,CAAC,CAAC;QACpB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;CACJ;AApBD,8BAoBC;AACD,SAAS,CAAC,SAAS,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC","sourcesContent":["export const enum AtomState {\n    ACTUAL = 'ACTUAL',\n    MAYBE_DIRTY = 'MAYBE_DIRTY',\n}\n\nclass Transaction {\n    changes: number[] = [];\n    changesLength = 0;\n    constructor(public transactionId: number, public atom?: AtomCalc) {}\n}\n\nclass TransactionManager {\n    private transactionIdIdx = 0;\n    current = new Transaction(this.transactionIdIdx++, undefined);\n    private stack: Transaction[] = [this.current];\n    private pos = 0;\n    start(atom: AtomCalc) {\n        if (this.pos === this.stack.length - 1) {\n            this.stack.push(new Transaction(this.transactionIdIdx++, atom));\n        }\n        this.possibleToUseAtomAsSlave(atom);\n        this.current = this.stack[++this.pos];\n        this.current.changesLength = atom.masters.length;\n        this.current.atom = atom;\n        if (this.current.changesLength > this.current.changes.length) {\n            this.current.changes[this.current.changesLength - 1] = -1;\n        }\n    }\n\n    end() {\n        this.current.atom = void 0;\n        this.current = this.stack[--this.pos];\n    }\n\n    possibleToUseAtomAsSlave(atom: Atom) {\n        for (let i = 1; i <= this.pos; i++) {\n            const transaction = this.stack[i];\n            if (transaction.atom === atom) {\n                const path = [];\n                for (let j = i; j <= this.pos; j++) {\n                    path.push(this.stack[j].atom!.name);\n                }\n                throw new Error(`Cyclic dependency detected: ${path.join('->')}`);\n            }\n            // if (transaction.transactionId === atom.createdInTransaction) {\n            // return false;\n            // }\n        }\n        return true;\n    }\n}\n\nconst trxManager = new TransactionManager();\n\nconst updateList = { list: [] as AtomValue[], pos: 0 };\n\nexport function run() {\n    for (let i = 0; i < updateList.pos; i++) {\n        const atom = updateList.list[i];\n        actualize(atom);\n        updateList.list[i] = undefined!;\n    }\n    updateList.pos = 0;\n}\n/*\nexport class Atom<T = {}> {\n    slaves?: Atom[] = void 0;\n    masters: (Atom | {})[] = undefined!;\n    calcFun?: () => T = void 0;\n    value: T = undefined!;\n    state: AtomState = AtomState.ACTUAL;\n    name?: string;\n    createdInTransaction = trxManager.current.transactionId;\n\n    constructor() {}\n\n    static value<T>(value: T, name?: string) {\n        const atom = new Atom<T>();\n        atom.value = value;\n        atom.name = name;\n        return atom;\n    }\n\n    static calc<T>(fn: () => T, name?: string) {\n        const atom = new Atom<T>();\n        atom.name = name;\n        atom.calcFun = fn;\n        atom.state = AtomState.MAYBE_DIRTY;\n        return atom;\n    }\n\n    static autorun(fn: () => void, name?: string) {\n        const atom = Atom.calc(fn, name);\n        atom.get();\n        return atom;\n    }\n\n    detach() {\n        for (let i = 0; i < this.masters.length; i += 2) {\n            const parent = this.masters[i] as Atom;\n            for (let j = 0; j < parent.slaves!.length; j++) {\n                if (this === parent.slaves![j]) {\n                    parent.slaves!.splice(j, 2);\n                    break;\n                }\n            }\n        }\n        while (this.masters.length > 0) this.masters.pop();\n    }\n\n    set(value: T) {\n        // console.log('set', value, this);\n        this.value = value;\n        updateList.list[updateList.pos++] = this;\n        this.setChildrenMaybeState();\n    }\n\n    actualize() {\n        console.log('actualize', this.name, this.state, this.value);\n        if (this.state === AtomState.MAYBE_DIRTY) {\n            this.calc(false);\n        }\n        if (this.slaves !== void 0) {\n            loop: for (let i = 0; i < this.slaves.length; i++) {\n                const child = this.slaves[i];\n                for (let i = 0; i < child.masters.length; i += 2) {\n                    const master = child.masters[i] as Atom;\n                    // console.log('master', master);\n                    if (master === child) continue;\n                    if (master.state === AtomState.MAYBE_DIRTY) {\n                        continue loop;\n                    }\n                }\n                if (child.state !== AtomState.ACTUAL) {\n                    child.actualize();\n                }\n            }\n        }\n    }\n\n    setChildrenMaybeState() {\n        if (this.slaves !== void 0) {\n            for (let i = 0; i < this.slaves.length; i++) {\n                const child = this.slaves[i];\n                if (child.state === AtomState.ACTUAL) {\n                    child.state = AtomState.MAYBE_DIRTY;\n                    child.setChildrenMaybeState();\n                }\n            }\n        }\n    }\n\n    removeChild(child: Atom) {\n        for (let i = 0; i < this.slaves!.length; i++) {\n            if (child === this.slaves![i]) {\n                this.slaves!.splice(i, 1);\n                return;\n            }\n        }\n    }\n\n    processTransaction() {\n        let shift = 0;\n        for (let i = 0; i < trxManager.current.changesLength; i += 2) {\n            if (trxManager.current.changes[i] !== trxManager.current.transactionId) {\n                const parent = this.masters[i - shift] as Atom;\n                parent.removeChild(this);\n                this.masters.splice(i - shift, 2);\n                shift += 2;\n            }\n        }\n    }\n\n    calc(setChildrenMaybeState: boolean) {\n        trxManager.start(this);\n        console.log('precalc', this.name, this.value);\n        try {\n            const newValue = this.calcFun!();\n            const hasChanged = newValue !== this.value;\n            if (hasChanged && setChildrenMaybeState) {\n                this.setChildrenMaybeState();\n            }\n            this.processTransaction();\n            this.state = AtomState.ACTUAL;\n            this.value = newValue;\n            return hasChanged;\n        } finally {\n            trxManager.end();\n            console.log('postcalc', this.name, this.value);\n        }\n    }\n\n    calcIfNeeded() {\n        console.log('calcIfNeeded', this.name, this.state, this.value);\n        if (this.state === AtomState.MAYBE_DIRTY) {\n            if (this.masters === void 0) {\n                this.masters = [];\n                return this.calc(true);\n            }\n            for (let i = 0; i < this.masters.length; i += 2) {\n                const parent = this.masters[i] as Atom;\n                const value = this.masters[i + 1];\n                if (parent.value !== value || parent.calcIfNeeded()) {\n                    if (this.calc(true)) {\n                        return true;\n                    }\n                }\n            }\n            this.state = AtomState.ACTUAL;\n        }\n        return false;\n    }\n\n    addChild(atom: Atom) {\n        if (this.slaves === void 0) {\n            this.slaves = [];\n        }\n        for (let i = 0; i < this.slaves.length; i++) {\n            const child = this.slaves[i];\n            if (atom === child) {\n                return i;\n            }\n        }\n        this.slaves.push(atom);\n        return -1;\n    }\n\n    addParent(atom: Atom) {\n        for (let i = 0; i < this.masters.length; i += 2) {\n            const parent = this.masters[i];\n            if (parent === atom) {\n                return i;\n            }\n        }\n        this.masters.push(atom, atom.value);\n        return -1;\n    }\n\n    processMaster() {\n        const { current } = trxManager;\n        if (current.atom !== void 0) {\n            // if (!trxManager.possibleToUseAtomAsSlave(this)) {\n            //     return;\n            // }\n            const foundPos = current.atom.addParent(this);\n            if (foundPos === -1) {\n                this.addChild(current.atom);\n            } else {\n                current.changes[foundPos] = current.transactionId;\n            }\n        }\n    }\n\n    get() {\n        this.calcIfNeeded();\n        this.processMaster();\n        return this.value;\n    }\n}\n*/\n\nfunction actualize(atom: Atom) {\n    console.log('actualize', atom.name, atom.value);\n    if (atom.slaves !== void 0) {\n        loop: for (let i = 0; i < atom.slaves.length; i++) {\n            const child = atom.slaves[i];\n            for (let i = 0; i < child.masters.length; i += 2) {\n                const master = child.masters[i] as Atom;\n                // console.log('master', master);\n                if (master === child) continue;\n                if (master.state === AtomState.MAYBE_DIRTY) {\n                    continue loop;\n                }\n            }\n            if (child.state === AtomState.MAYBE_DIRTY) {\n                calc(child, false);\n                actualize(child);\n            }\n        }\n    }\n}\n\nfunction setChildrenMaybeState(atom: Atom) {\n    if (atom.slaves !== void 0) {\n        for (let i = 0; i < atom.slaves.length; i++) {\n            const child = atom.slaves[i];\n            if (child.state === AtomState.ACTUAL) {\n                child.state = AtomState.MAYBE_DIRTY;\n                setChildrenMaybeState(child);\n            }\n        }\n    }\n}\n\nfunction removeChild(atom: Atom, child: Atom) {\n    if (atom.slaves !== void 0) {\n        for (let i = 0; i < atom.slaves.length; i++) {\n            if (child === atom.slaves[i]) {\n                atom.slaves.splice(i, 1);\n                return;\n            }\n        }\n    }\n}\n\nfunction addChild(atom: Atom, atomChild: AtomCalc) {\n    if (atom.slaves === void 0) {\n        atom.slaves = [];\n    }\n    for (let i = 0; i < atom.slaves.length; i++) {\n        const child = atom.slaves[i];\n        if (atomChild === child) {\n            return i;\n        }\n    }\n    atom.slaves.push(atomChild);\n    return -1;\n}\n\nfunction addParent(atom: AtomCalc, atomParent: Atom) {\n    for (let i = 0; i < atom.masters.length; i += 2) {\n        const parent = atom.masters[i];\n        if (parent === atomParent) {\n            return i;\n        }\n    }\n    atom.masters.push(atomParent, atomParent.value);\n    return -1;\n}\n\nfunction processMaster(atom: Atom) {\n    const { current } = trxManager;\n    if (current.atom !== void 0) {\n        // if (!trxManager.possibleToUseAtomAsSlave(this)) {\n        //     return;\n        // }\n        const foundPos = addParent(current.atom, atom);\n        if (foundPos === -1) {\n            addChild(atom, current.atom);\n        } else {\n            current.changes[foundPos] = current.transactionId;\n        }\n    }\n}\n\nfunction calc(atom: AtomCalc, setChildrenMaybeState1: boolean) {\n    trxManager.start(atom);\n    console.log('precalc', atom.name, atom.value);\n    try {\n        const newValue = atom.calcFun();\n        const hasChanged = newValue !== atom.value;\n        if (hasChanged && setChildrenMaybeState1) {\n            setChildrenMaybeState(atom);\n        }\n        processTransaction(atom);\n        atom.state = AtomState.ACTUAL;\n        atom.value = newValue;\n        return hasChanged;\n    } finally {\n        trxManager.end();\n        console.log('postcalc', atom.name, atom.value);\n    }\n}\n\nfunction calcIfNeeded(atom: AtomCalc) {\n    console.log('calcIfNeeded', atom.name, atom.state, atom.value);\n    if (atom.masters === void 0) {\n        atom.masters = [];\n        return calc(atom, true);\n    }\n    for (let i = 0; i < atom.masters.length; i += 2) {\n        const parent = atom.masters[i] as Atom;\n        const value = atom.masters[i + 1];\n        if (parent.value !== value || (parent.state === AtomState.MAYBE_DIRTY && calcIfNeeded(parent))) {\n            if (calc(atom, true)) {\n                return true;\n            }\n        }\n    }\n    atom.state = AtomState.ACTUAL;\n    return false;\n}\n\nfunction processTransaction(atom: AtomCalc) {\n    let shift = 0;\n    for (let i = 0; i < trxManager.current.changesLength; i += 2) {\n        if (trxManager.current.changes[i] !== trxManager.current.transactionId) {\n            const parent = atom.masters[i - shift] as Atom;\n            removeChild(parent, atom);\n            atom.masters.splice(i - shift, 2);\n            shift += 2;\n        }\n    }\n}\n\nexport type Atom = AtomCalc | AtomValue;\n\nexport class AtomCalc<T = {}> {\n    slaves?: AtomCalc[] = void 0;\n    masters: (Atom | {})[] = undefined!;\n    calcFun: () => T;\n    value: T = undefined!;\n    state = AtomState.MAYBE_DIRTY;\n\n    constructor(calcFun: () => T, public name?: string) {\n        this.calcFun = calcFun;\n    }\n\n    static autorun<T>(calcFun: () => T, name?: string) {\n        const atom = new AtomCalc<T>(calcFun, name);\n        atom.get();\n        return atom;\n    }\n\n    detach() {\n        for (let i = 0; i < this.masters.length; i += 2) {\n            const parent = this.masters[i] as Atom;\n            if (parent.slaves !== void 0) {\n                for (let j = 0; j < parent.slaves.length; j++) {\n                    if (this === parent.slaves[j]) {\n                        parent.slaves.splice(j, 2);\n                        break;\n                    }\n                }\n            }\n        }\n        while (this.masters.length > 0) this.masters.pop();\n    }\n\n    get() {\n        if (this.state === AtomState.MAYBE_DIRTY) {\n            calcIfNeeded(this);\n        }\n        processMaster(this);\n        return this.value;\n    }\n}\n\nexport class AtomValue<T = {}> {\n    slaves?: AtomCalc[] = void 0;\n    value: T;\n    // createdInTransaction = trxManager.current.transactionId;\n    state: AtomState.ACTUAL;\n\n    constructor(value: T, public name?: string) {\n        this.value = value;\n    }\n\n    set(value: T) {\n        this.value = value;\n        updateList.list[updateList.pos++] = this;\n        setChildrenMaybeState(this);\n    }\n\n    get() {\n        processMaster(this);\n        return this.value;\n    }\n}\nAtomValue.prototype.state = AtomState.ACTUAL;\n"]}},"hash":"2c403c986b9eebe84086cb04ec4a31d7","cacheData":{"env":{}}}